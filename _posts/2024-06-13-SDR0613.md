
Creating a new module is typical <br/>
We can change MIN IN, MIN OUT, .. <br/>

**Advanced Block Use** <br/>
BPSK Data loss, power efficiency <br/>
Phase lock loop setting <br/>
Downsampling -> Clock recovery module <br/>
We've done bit level, but specific sequency byte level or file level data communication wasn't performed last time <br/>
Pre-embry as streamworks <br/>
Based on this, access code and based on corrleation, based on highest point bit level synchronization is done <br/>
The block between here doesn't exist <br/>
Based on Tims Sink,we will see the level <br/>
```
switch(d_state){
		
		case STATE_WAITING:
			get_tags_in_range(tags, 0,
					nitems_read(0),
					nitems_read(0) + d_preamble_len, d_length_rx);
				//std::cout << "Searching" << nitems_read(0) << " " 
				 std::cout	<<d_preamble_len << " "<< tags.size() << std::endl;
			
			if(tags.size() == 0){
				consume_each(d_preamble_len);
			} else {

				consume_each(tags[0].offset-nitems_read(0));
				d_state = STATE_TAG_DETECT;
				d_count = 0;
				std::cout << "Move on STATE_TAG_DETECT" << std::endl;
			}
		break;

		case STATE_TAG_DETECT:
			if(d_count < d_num_data){
				std::cout << "Searching" << nitems_written(0) << " " 
					<<d_count*d_frame_size << " "<< tags.size() << std::endl;
				memcpy(out, in, d_frame_size*sizeof(unsigned char));
				add_item_tag(0,
					nitems_written(0),
					pmt::string_to_symbol(d_len_tag_key),
					pmt::from_long(d_frame_size),
					pmt::string_to_symbol(name())
				);
				produce(0, d_frame_size);
				consume_each(d_frame_size+d_search_len-d_preamble_len);
				d_count += 1;
				d_state = STATE_WAITING;
				std::cout << "counting" << std::endl;
			}else{

				d_state = STATE_WAITING;
				std::cout << "Move on STATE_WAITING" << d_count << " " << std::endl;
			}
		break;

		default:
			throw std::runtime_error("invalid state");
		break;
			
	}
        // Do <+signal processing+>
        // Tell runtime system how many input items we consumed on
        // each input stream.

        // Tell runtime system how many output items we produced.
	return WORK_CALLED_PRODUCE;
    }
```

when we find tag, waiting, stays in the loop of preamble <br/>
tag synchronized, <br/>
sending the preamble_length, means sending the data by preprocessing it <br/>
When we don't know tag.. <br/>
Set the state, we divide the waiting state to two ways <br/>

![SDR0613_1](https://github.com/growingpenguin/growingpenguin.github.io/assets/110277903/ffdf925d-c9a0-4d1b-b70f-6c0ede2614f2) <br/>

